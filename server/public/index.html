<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>
</head>
<body>
<button onclick="history.push('/')">首页</button>
<button onclick="history.push('/about')">关于我</button>
<button onclick="history.replace('/xxxx')">替换</button>
	<script type="text/javascript">
		/*
		前端路由的实现原理：一种是哈希模式，一种是history模式，h5api
			哈希模式 window.location.hash
			history.pushState(state, null, url)

		目前浏览器都支持history.pushState(state, null, url)

		目前无论是哈希模式还是h5模式，都可以使用上面的这一种api

		当是哈希模式的时候就可以：history.pushState(state, null, "#/apple")

		两种路由的区别：哈希 h5模式
			1- hash模式的好处就是锚点：刷新页面的时候不会向服务器发送请求，缺陷不支持服务端渲染（不能做seo优化），不会产生404，丑
			2- history模式，特点就是路径漂亮，没有#，和正常页面切换一样，刷新的时候会向服务器发送请求，资源不存在，会出现404，解决方案：渲染首页，首页会根据路径重新跳转

		自己实现一个路由核心模块：

		*/
        /**
         *
         * @param back 当前路径的前一个路径是哪里？？
         * @param current 当前的路径
         * @param forward 要去哪个路径
         * @param replace 是否push还是replace
         * @param computedScroll 是否 需要记住当前的滚动条的位置
         */
        function buildState(back, current,forward, replace= false,computedScroll = false) {
            return {
                back,
                current,
                forward,
                replace,
                scroll: computedScroll ? {left: window.pageXOffset, top: window.pageYOffset} : null,
                // 默认是从2开始的
                position: window.history.length - 1 // 跳转的历史记录
            }
        }
		// 创建一个当前的location对象，因为location对象上面可以拿到pathname 等属性
		function createCurrentLocation() {
			const {pathname, search, hash} = window.location
            // console.log(window.location)
			// 在浏览器的URL中，#（井号）后面确实会被认为是hash部分
			return pathname + search + hash
		}
		function useHistoryStateNavigation() {
			const currentLocation = {
				value: createCurrentLocation()
			}
			const historyState = {
				value: window.history.state
			}
			// console.log(currentLocation, historyState)
            // console.log(historyState, 62)
            // 第一次刷新页面，此时没有任何状态，那么我就自己维护一个状态  后退后是哪个，当前的是哪个 要去哪里
            // 我是用的push跳转还是replace跳转，跳转的滚动条在哪里，跳转后的滚动条的位置
            if (!historyState.value) {

                const res = buildState(null, currentLocation.value, null, true)
                // console.log(res)
                changeLocation(currentLocation.value, res, true)
            }

            // to 目的地
            // state 状态
            // replace模式
            function changeLocation(to, state, replace) {
                // 默认来更新一下状态
                window.history[replace ? 'replaceState' : 'pushState'](state, null, to)
                historyState.value = state // 将自己生成的状态同步到 路由系统之中
                // console.log(state)
            }

            function push(to, data) {
                // push 里面会changeLocation两次，希望有一个跳转的过程，便于更好的控制
                // 去哪里，带的新的状态是什么？ pushState
                // a -> b 将要跳转 和 跳转完成
                const currentState = Object.assign({},
                    historyState.value, // 当前的逻辑/状态
                    {
                        forward: to,
                        scroll: {
                            left: window.pageXOffset,
                            top: window.pageYOffset
                        }
                    }
                )
                // 本质是没有跳转的，只是更新了状态，后续再vue之中可以详细的监控到vue的状态的变化
                changeLocation(currentState.current, currentState, true)


                const state = Object.assign(
                    {},
                    buildState(currentLocation.value, to, null),
                    {
                        position: currentState.position + 1
                    },
                    data
                )

                // 才是真正的更改了路径
                changeLocation(to,  state, false) // 真的发生跳转
                currentLocation.value = to // 替换后需要将路径变为现在的路径
                // 跳转的过程更加精细
                // 跳转的时候，我需要做两个状态
                /*
                跳转前：从哪里去哪里
                跳转后：
                 */
            }
            function replace(to, data) {
                // 去哪里，带的新的状态是什么？
                const state = Object.assign({},
                    buildState(historyState.value.back, to,historyState.value.forward, true),
                    data
                )
                // replaceState
                changeLocation(to, state, true)
                currentLocation.value = to // 替换后需要将路径变为现在的路径
            }

            return {
                location: currentLocation,
                state: historyState,
                push,
                replace
            }
		}



        // 前进后退的时候 需要更新 historyState 和 currentLocation 这两个变量
        function useHistoryListeners(historyState, currentLocation) {
            const listeners = []
            const popStateHandler = ({state}) => { // state是最新的状态，已经前进后退完毕后的状态
                console.log(state, 145)
                // 需要知道当前要去哪里？？
                const to = createCurrentLocation()
                // 从那里来了
                const from = currentLocation.value
                const fromState = historyState.value // 从哪里来的状态


                currentLocation.value = to
                historyState.value = state // state可能为空 null


                // 看是前进还是后退？？？
                let isBack = (state.position - fromState.position) < 0

                // console.log(isBack, 161)
                listeners.forEach(listener => listener(to, from, {isBack}))

                // 用户在这里扩展？？？

            }
            // 监听前进 后退
            window.addEventListener('popstate', popStateHandler) // 只能监听浏览器的前进后退

            function listen(cb) {
                listeners.push(cb)
            }

            return {
                listen
            }

        }
		function createWebHistory() {
			const historyNavigation = useHistoryStateNavigation()

            // 监听浏览器go back时候的状态的变化
            const historyListeners = useHistoryListeners(historyNavigation.state, historyNavigation.location)



            const routerHistory = Object.assign({}, historyNavigation, historyListeners)

            Object.defineProperty(routerHistory, 'location', {
                get() {
                    return historyNavigation.location.value
                }
            })
            Object.defineProperty(routerHistory, 'state', {
                get() {
                    return historyNavigation.state.value
                }
            })

            return routerHistory

		}

		// 当前的路径 状态 路由的信息
		const routerHistory = createWebHistory() // 默认使用h5的路由

        console.log(routerHistory.location, routerHistory.state)
        routerHistory.listen((to, from , {isBack}) => {
            console.log(to, from , isBack)
        })

		// 路由系统最基本的需要包含当前的路径 当前路径下的状态 还需要提供两个切换路径的方法 push replace

		// 实现路由监听 路径变化，需要通知用户


	</script>
</body>
</html>





















